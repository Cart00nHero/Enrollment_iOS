//
//  ToolMan.swift
//  WhatToEat
//
//  Created by YuCheng on 2021/3/3.
//  Copyright © 2021 YuCheng. All rights reserved.
//

import Foundation
import UIKit
import Flynn

class ToolMan: Actor {
    private func _beResizeImage(
        sender: Actor,image: UIImage, newSize: CGSize,
        _ complete: @escaping (UIImage) -> Void) {
        let newImage = resizeImage(image: image, targetSize: newSize)
        complete(newImage)
    }
    private func _beBase64ImageString(
        sender: Actor,image: UIImage,
        _ complete:@escaping(String) -> Void) {
        /*
         //jpeg格式 compressionQuality: 压缩质量
         guard let imageData = image.jpegData(compressionQuality: 1) else {
         return
         }*/
        //png格式
        guard let imageData = image.pngData() else {
            return
        }
        let base64ImageStr =
            imageData.base64EncodedString(options: .lineLength64Characters)
        sender.unsafeSend {
            complete(base64ImageStr)
        }
    }
    private func _beDecodeQrCode(
        sender:Actor, image: UIImage,
        _ complete:@escaping([String]) -> Void) {
        var messages: [String] = []
        if let features = detectQRCode(image), !features.isEmpty{
            for case let row as CIQRCodeFeature in features{
                let qrcodeMsg = row.messageString ?? ""
                if !qrcodeMsg.isEmpty {
                    messages.append(qrcodeMsg)
                }
            }
            if messages.count > 0 {
                sender.unsafeSend {
                    complete(messages)
                }
            }
        }
    }
    
    private func detectQRCode(_ image: UIImage?) -> [CIFeature]? {
        if let image = image, let ciImage = CIImage.init(image: image){
            var options: [String: Any]
            let context = CIContext()
            options = [CIDetectorAccuracy: CIDetectorAccuracyHigh]
            let qrDetector = CIDetector(ofType: CIDetectorTypeQRCode, context: context, options: options)
            if ciImage.properties.keys.contains((kCGImagePropertyOrientation as String)){
                options = [CIDetectorImageOrientation: ciImage.properties[(kCGImagePropertyOrientation as String)] ?? 1]
            } else {
                options = [CIDetectorImageOrientation: 1]
            }
            let features = qrDetector?.features(in: ciImage, options: options)
            return features
            
        }
        return nil
    }
    private func _beBase64ToImage(
        sender:Actor,strBase64: String,complete:@escaping (UIImage) -> Void) {
        let dataDecoded : Data = Data(base64Encoded: strBase64, options: .ignoreUnknownCharacters)!
        guard let decodedimage = UIImage(data: dataDecoded) else { return }
        sender.unsafeSend {
            complete(decodedimage)
        }
    }
    private func resizeImage(image: UIImage, targetSize: CGSize) -> UIImage {
        let size = image.size
        
        let widthRatio  = targetSize.width  / size.width
        let heightRatio = targetSize.height / size.height
        
        // Figure out what our orientation is, and use that to form the rectangle
        var newSize: CGSize
        if(widthRatio > heightRatio) {
            newSize = CGSize(width: size.width * heightRatio, height: size.height * heightRatio)
        } else {
            newSize = CGSize(width: size.width * widthRatio,  height: size.height * widthRatio)
        }
        
        // This is the rect that we've calculated out and this is what is actually used below
        let rect = CGRect(x: 0, y: 0, width: newSize.width, height: newSize.height)
        
        // Actually do the resizing to the rect using the ImageContext stuff
        UIGraphicsBeginImageContextWithOptions(newSize, false, 1.0)
        image.draw(in: rect)
        let newImage = UIGraphicsGetImageFromCurrentImageContext()
        UIGraphicsEndImageContext()
        
        return newImage!
    }
    private func _beConvertQRSMS(
        sender:Actor,smsText: String,
        _ complete:@escaping (_ success: Bool, _ smsText: String) -> Void) {
        let tempText = smsText
        if tempText.lowercased().hasPrefix("smsto") {
            let splitArray = smsText.split(separator: ":")
            if splitArray.count >= 3 {
                let sliceArr = splitArray[2 ..< splitArray.count]
                let bodyText = NSMutableString()
                for text in sliceArr {
                    bodyText.append(String(text))
                }
                let sendSMSText = "sms:\(splitArray[1])&body=\(bodyText)"
                sender.unsafeSend {
                    complete(true,sendSMSText)
                }
                return
            }
        }
        sender.unsafeSend {
            complete(false,smsText)
        }
    }
}

// MARK: - Autogenerated by FlynnLint
// Contents of file after this marker will be overwritten as needed

extension ToolMan {

    @discardableResult
    public func beResizeImage(sender: Actor, image: UIImage, newSize: CGSize, _ complete: @escaping (UIImage) -> Void) -> Self {
        unsafeSend { self._beResizeImage(sender: sender, image: image, newSize: newSize, complete) }
        return self
    }
    @discardableResult
    public func beBase64ImageString(sender: Actor, image: UIImage, _ complete: @escaping(String) -> Void) -> Self {
        unsafeSend { self._beBase64ImageString(sender: sender, image: image, complete) }
        return self
    }
    @discardableResult
    public func beDecodeQrCode(sender: Actor, image: UIImage, _ complete: @escaping([String]) -> Void) -> Self {
        unsafeSend { self._beDecodeQrCode(sender: sender, image: image, complete) }
        return self
    }
    @discardableResult
    public func beBase64ToImage(sender: Actor, strBase64: String, complete: @escaping (UIImage) -> Void) -> Self {
        unsafeSend { self._beBase64ToImage(sender: sender, strBase64: strBase64, complete: complete) }
        return self
    }
    @discardableResult
    public func beConvertQRSMS(sender: Actor, smsText: String, _ complete: @escaping (_ success: Bool, _ smsText: String) -> Void) -> Self {
        unsafeSend { self._beConvertQRSMS(sender: sender, smsText: smsText, complete) }
        return self
    }

}
