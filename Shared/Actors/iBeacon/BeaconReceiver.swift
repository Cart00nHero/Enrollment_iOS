//
//  BeaconReceiver.swift
//  ActorDeveloper
//
//  Created by YuCheng on 2021/5/19.
//

import Foundation
import Flynn
import CoreLocation

fileprivate class BeaconDetector : NSObject, CLLocationManagerDelegate {
    
    static let shared = BeaconDetector()
    private let locationManager: CLLocationManager = CLLocationManager()
    private var receiverId = "default_id"
    
    func registerDetector(receiverId: String) {
        locationManager.delegate = self
        locationManager.pausesLocationUpdatesAutomatically = false
        locationManager.requestAlwaysAuthorization()
        locationManager.startUpdatingLocation()
        self.receiverId = receiverId
    }
    
    func startScanning() {
        let uuid = UUID(uuidString: UUID().uuidString)!
        //find all beacons matching the uuid major and minor
        let constraint = CLBeaconIdentityConstraint(uuid: uuid)
        let beaconRegion = CLBeaconRegion(uuid: uuid, identifier: receiverId)
        locationManager.startMonitoring(for: beaconRegion)
        locationManager.startRangingBeacons(satisfying: constraint)
    }
    
    func locationManager(_ manager: CLLocationManager, didRangeBeacons beacons: [CLBeacon], in region: CLBeaconRegion) {
        if beacons.count > 0 {
            NSLog("Found beacon")
            for beacon in beacons {
                
                NSLog("Found becaon with uuid " + beacon.uuid.uuidString + " and major:" + beacon.major.stringValue + " and minor" + beacon.minor.stringValue)
                
                if(beacon.proximity == CLProximity.near) {
                    NSLog("Beacon distance was near")
                } else if (beacon.proximity == CLProximity.far) {
                    NSLog("Beacon distance was far")
                } else if(beacon.proximity == CLProximity.immediate) {
                    NSLog("Beacon distance was immediate")
                } else if (beacon.proximity == CLProximity.unknown) {
                    NSLog("Beacon distance is unknown")
                }
            }
            
        } else {
            NSLog("Beacon not found")
        }
    }
    
    func locationManager(_ manager: CLLocationManager, didEnterRegion region: CLRegion) {
        let beaconRegion = region as! CLBeaconRegion
        print("Did enter region: " + (beaconRegion.major?.stringValue)!)
    }
    
    func locationManager(_ manager: CLLocationManager, didExitRegion region: CLRegion) {
        let beaconRegion = region as! CLBeaconRegion
        print("Did exit region: " + (beaconRegion.major?.stringValue)!)
    }
    
    func locationManager(_ manager: CLLocationManager, didChangeAuthorization status: CLAuthorizationStatus) {
        if status == .authorizedAlways {
            if CLLocationManager.isMonitoringAvailable(for: CLBeaconRegion.self) {
                if CLLocationManager.isRangingAvailable() {
                    startScanning()
                }
            }
        }
    }
    
    func locationManager(_ manager: CLLocationManager, monitoringDidFailFor region: CLRegion?, withError error: Error) {
        NSLog(error.localizedDescription)
    }
}

class BeaconReceiver: Actor {
    private let detector = BeaconDetector.shared
    private func _beRegister(receiverId: String) {
        detector.registerDetector(receiverId: receiverId)
    }
}

// MARK: - Autogenerated by FlynnLint
// Contents of file after this marker will be overwritten as needed

extension BeaconReceiver {

    @discardableResult
    public func beRegister(receiverId: String) -> Self {
        unsafeSend { self._beRegister(receiverId: receiverId) }
        return self
    }

}
