//
//  WatchCommunicator.swift
//  iListen
//
//  Created by 林祐正 on 2021/4/12.
//  Copyright © 2021 SmartFun. All rights reserved.
//

import Foundation
import Flynn
import WatchConnectivity

enum WatchConnectStatus {
    case OK,NotSupported,
         NotMatched,
         NotInstall,
         NotActived,NotReachable
}
protocol WatchProtocol {
    @discardableResult
    func beSession(
        activationDidCompleteWith activationState: WCSessionActivationState, error: Error?) -> Self
    @discardableResult
    func beSessionDidBecomeInactive() -> Self
    @discardableResult
    func beSessionDidDeactivate() -> Self
    @discardableResult
    func beSession(didReceiveMessage message: [String : Any]) -> Self
    @discardableResult
    func beSession(
        didReceiveMessage message: [String : Any],
        replyHandler: @escaping ([String : Any]) -> Void) -> Self
    @discardableResult
    func beSession(
        didReceiveApplicationContext applicationContext: [String : Any]) -> Self
}
extension WatchProtocol {
    func beSession(
        didReceiveApplicationContext applicationContext: [String : Any]) -> Self {
        return self
    }
}
fileprivate class WatchConnector: NSObject, WCSessionDelegate {
    let wcSession: WCSession = WCSession.default
    var sender: WatchProtocol?
    
    override init() {
        super.init()
        if WCSession.isSupported() {
            wcSession.delegate = self
            wcSession.activate()
        }
    }
    func isComplicationEnabled() -> Bool {
        return WCSession.default.isComplicationEnabled
    }
    // 檢查連接狀況
    func checkConnectStatus() -> WatchConnectStatus {
        if !WCSession.isSupported() {
            // 目前iPhone不支援與iWatch通訊
            return .NotSupported
        }
        if !WCSession.default.isPaired {
            // 未配對到iWatch
            return .NotMatched
        }
        if !WCSession.default.isWatchAppInstalled{
            // 對象設備未安裝 App
            return .NotInstall
        }
        if WCSession.default.activationState != .activated {
            return .NotActived
        }
        if !WCSession.default.isReachable {
            return .NotReachable
        }
        return .OK
    }
    
    // MARK: - Delegate implements
    func session(
        _ session: WCSession,
        activationDidCompleteWith activationState: WCSessionActivationState,
        error: Error?) {
        sender?.beSession(
            activationDidCompleteWith: activationState, error: error)
    }
    func sessionDidBecomeInactive(_ session: WCSession) {
        sender?.beSessionDidBecomeInactive()
    }
    
    func sessionDidDeactivate(_ session: WCSession) {
        sender?.beSessionDidDeactivate()
    }
    func session(_ session: WCSession, didReceiveMessage message: [String : Any]) {
        sender?.beSession(didReceiveMessage: message)
    }
    func session(_ session: WCSession, didReceiveMessage message: [String : Any], replyHandler: @escaping ([String : Any]) -> Void) {
        sender?.beSession(didReceiveMessage: message, replyHandler: replyHandler)
    }
    func session(_ session: WCSession, didReceiveApplicationContext applicationContext: [String : Any]) {
        sender?.beSession(didReceiveApplicationContext: applicationContext)
    }
}
class WatchCommunicator: Actor {
    private let connector = WatchConnector()
    
    private func _beRegisterSender(_ sender: WatchProtocol) {
        connector.sender = sender
    }
    private func _beCheckConnectStatus(
        sender:Actor,
        _ complete: @escaping (WatchConnectStatus) -> Void) {
        let status = connector.checkConnectStatus()
        sender.unsafeSend {
            complete(status)
        }
    }
    private func _beSendMessage(
        sender: Actor,
        message: [String : Any],
        _ complete: (([String : Any]?,Error?) -> Void)?) {
        connector.wcSession.sendMessage(message) { (replyMessage) in
            if complete != nil {
                sender.unsafeSend {
                    complete!(replyMessage,nil)
                }
            }
        } errorHandler: { (error) in
            if complete != nil {
                sender.unsafeSend {
                    complete!(nil,error)
                }
            }
        }
    }
}

// MARK: - Autogenerated by FlynnLint
// Contents of file after this marker will be overwritten as needed

extension WatchCommunicator {

    @discardableResult
    public func beRegisterSender(_ sender: WatchProtocol) -> Self {
        unsafeSend { self._beRegisterSender(sender) }
        return self
    }
    @discardableResult
    public func beCheckConnectStatus(sender: Actor, _ complete: @escaping (WatchConnectStatus) -> Void) -> Self {
        unsafeSend { self._beCheckConnectStatus(sender: sender, complete) }
        return self
    }
    @discardableResult
    public func beSendMessage(sender: Actor, message: [String : Any], _ complete: (([String : Any]?,Error?) -> Void)?) -> Self {
        unsafeSend { self._beSendMessage(sender: sender, message: message, complete) }
        return self
    }

}
