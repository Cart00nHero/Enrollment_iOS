//
//  PeerHost.swift
//  ActorDeveloper
//
//  Created by YuCheng on 2021/5/20.
//

import Foundation
import Flynn
import MultipeerConnectivity

protocol PeerHostProtocol {
    @discardableResult
    func beSession(peer peerID: MCPeerID, didChange state: MCSessionState) -> Self
    @discardableResult
    func beSession(didReceive data: Data, fromPeer peerID: MCPeerID) -> Self
    @discardableResult
    func beSession(didReceive stream: InputStream, withName streamName: String, fromPeer peerID: MCPeerID) -> Self
    @discardableResult
    func beSession(didStartReceivingResourceWithName resourceName: String, fromPeer peerID: MCPeerID, with progress: Progress) -> Self
    @discardableResult
    func beSession(didFinishReceivingResourceWithName resourceName: String, fromPeer peerID: MCPeerID, at localURL: URL?, withError error: Error?) -> Self
}
fileprivate class RoleOfHost: NSObject {
    
    private var session: MCSession!
    var delegate: PeerHostProtocol?
    
    func actPeerHost(name: String,serviceType:String,encryptionPreference: MCEncryptionPreference) {
        session = MCSession(peer: MCPeerID(displayName: name), securityIdentity: nil, encryptionPreference: encryptionPreference)
        session.delegate = self
    }
    func sendData(
        _ data: Data,toPeers:[MCPeerID],mode: MCSessionSendDataMode) {
        do {
            try session.send(data, toPeers: toPeers, with: mode)
        } catch let error {
            fatalError("send data error:\(error.localizedDescription)")
        }
    }
    func disconnect() {
        session.disconnect()
    }
    func mcSession() -> MCSession {
        return session
    }
}
extension RoleOfHost: MCSessionDelegate {
    func session(_ session: MCSession, peer peerID: MCPeerID, didChange state: MCSessionState) {
        delegate?.beSession(peer: peerID, didChange: state)
    }
    
    func session(_ session: MCSession, didReceive data: Data, fromPeer peerID: MCPeerID) {
        delegate?.beSession(didReceive: data, fromPeer: peerID)
    }
    
    func session(_ session: MCSession, didReceive stream: InputStream, withName streamName: String, fromPeer peerID: MCPeerID) {
        delegate?.beSession(didReceive: stream, withName: streamName, fromPeer: peerID)
    }
    
    func session(_ session: MCSession, didStartReceivingResourceWithName resourceName: String, fromPeer peerID: MCPeerID, with progress: Progress) {
        delegate?.beSession(didStartReceivingResourceWithName: resourceName, fromPeer: peerID, with: progress)
    }
    
    func session(_ session: MCSession, didFinishReceivingResourceWithName resourceName: String, fromPeer peerID: MCPeerID, at localURL: URL?, withError error: Error?) {
        delegate?.beSession(didFinishReceivingResourceWithName: resourceName, fromPeer: peerID, at: localURL, withError: error)
    }
}

class PeerHost: Actor {
    
    private let host = RoleOfHost()
    
    init(sender: PeerHostProtocol,peerName: String,
         serviceType: String,encryption: MCEncryptionPreference) {
        host.actPeerHost(name: peerName, serviceType: serviceType, encryptionPreference: encryption)
        host.delegate = sender
    }
    private func _beHostSession(
        sender: Actor, _ complete:@escaping(MCSession) -> Void) {
        sender.unsafeSend { [self] in
            complete(host.mcSession())
        }
    }
    private func _beSend(
        sender: Actor,data: Data,
        toPeers peers:[MCPeerID],mode: MCSessionSendDataMode,
        _ complete:(()->Void)?) {
        host.sendData(data, toPeers: peers, mode: mode)
        if complete != nil {
            sender.unsafeSend {
                complete!()
            }
        }
    }
    private func _beDisconnect() {
        host.disconnect()
    }
}

// MARK: - Autogenerated by FlynnLint
// Contents of file after this marker will be overwritten as needed

extension PeerHost {

    @discardableResult
    public func beHostSession(sender: Actor, _ complete: @escaping(MCSession) -> Void) -> Self {
        unsafeSend { self._beHostSession(sender: sender, complete) }
        return self
    }
    @discardableResult
    public func beSend(sender: Actor, data: Data, toPeers peers: [MCPeerID], mode: MCSessionSendDataMode, _ complete: (()->Void)?) -> Self {
        unsafeSend { self._beSend(sender: sender, data: data, toPeers: peers, mode: mode, complete) }
        return self
    }
    @discardableResult
    public func beDisconnect() -> Self {
        unsafeSend(_beDisconnect)
        return self
    }

}
